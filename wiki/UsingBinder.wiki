#summary Using Binder

= Introduction =

This is a short tutorial on how to use the Binder class.

= Creating a Binder =

To create a new Binder and tie it to a new or existing object, use the function *Binder.bindTo()*.  For this and the remaining examples, let's build up a new object from scratch.

{{{
var myObject = {};
var binder = Binder.bindTo( myObject );
}}}

= Setting properties =

You may set any property in the object graph via the *set()* method.  The notation is a simple dotted-path notation, similar to many web frameworks.  It also matches the same path that you would use if accessing the property directly in javascript.  The difference, and the value that Binder adds, is that it will transparently create all the objects necessary to reach that path if they don't already exist.  Continuing from the previous example, where we've created a binder for an empty object, let's set some properties:

{{{
binder.set( "username", "jdoe" );
binder.set( "email", "foo@bar.com" );
binder.set( "address.street", "123 Market St" );
binder.set( "address.city", "San Francisco" );
binder.set( "address.state", "California" );
binder.set( "phone[0].type", "home" );
binder.set( "phone[0].number", "555-1212" );
binder.set( "phone[1].type", "mobile" );
binder.set( "phone[1].number", "555-7878" );

var result = binder.target;
}}}

Our resulting object would then look like:
{{{
{ 
  username: "jdoe",
  email: "foo@bar.com",
  address: {
    street: "123 Market St",
    city: "San Francisco", 
    state: "California"
  },
  phone: [
    { type: "home", number: "555-1212" },
    { type: "mobile", number: "555-7878" }
  ]
}
}}}


= Getting properties =

You may also read property values using the same notation using the *get()* method.  Attempts to access invalid paths will not modify the bound object and will simply return *undefined*.

= Addtional notes on Arrays=
In addition to accessing individual array elements, it is also possible to access the array itself by omitting the index.  This provides a little more flexibility. particularly in form binding where we the array size is variable depending on the items selected.  For example:

{{{
binder.set( "options[]", "option1" );
binder.set( "options[]", "option2" );
}}}
will produce:
{{{
{
  options: [ "option1", "option2" ] 
}
}}}

Retrieving the attribute using the same notation returns the array itself.

= Binding to Forms=

While setting and getting properties by themselves isn't too useful, it can be used as the foundation of a simple, declarative form binding mechanism.  Consider:

{{{
<form>
  <input type="text" name="username"/>
  <input type="text" name="email"/>
  <input type="text" name="address.street"/>
  <input type="text" name="address.city"/>
  <input type="text" name="address.state"/>
  ...
</form>
}}}

If your form is AJAX based and leverages JSON or DWR, binder makes it trivial to convert this form to the corresponding object graph:

{{{
{
  username: "...",
  email: "...",
  address: {
    street: "...",
    city: "...",
    state: "..."
  }
}
}}}

To fill in a form based on object properties, use the *Binder.deserializeForm()* method.  Example:

{{{
  var myObj = {...};
  var myForm = ...;
  Binder.deserializeForm( myForm, myObj );
}}}

Likewise, to convert the form input back into the object representation, use *Binder.serializeForm()*.  Example:

{{{
  var myForm = ...;
  var myObj = Binder.serializeForm( myForm );
}}}

A simple demo of this can be found in SVN as demo/formdemo.html.

At the moment there is no type hinting or conversion available, though this is likely to be added in the near future.